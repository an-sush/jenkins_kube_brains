# Default values for jenkins.
# This is a YAML-formatted file.
# Declare name/value pairs to be passed into your templates.
# name: value

## Overrides for generated resource names
# See templates/_helpers.tpl
# nameOverride:
# fullnameOverride:

Master:
  Name: jenkins-master
  Image: "jenkins/jenkins"
  ImageTag: "lts"
  ImagePullPolicy: "Always"
# ImagePullSecret: jenkins
  Component: "jenkins-master"
  UseSecurity: true
  # SecurityRealm:
  # Optionally configure a different AuthorizationStrategy using Jenkins XML
  # AuthorizationStrategy: |-
  #    <authorizationStrategy class="hudson.security.FullControlOnceLoggedInAuthorizationStrategy">
  #      <denyAnonymousReadAccess>true</denyAnonymousReadAccess>
  #    </authorizationStrategy>
  HostNetworking: false
  AdminUser: admin
  # Leave this blank for autogenerated...
  # AdminPassword: changeme
  resources:
    requests:
      cpu: "50m"
      memory: "256Mi"
    limits:
      cpu: "2000m"
      memory: "2048Mi"
  # Environment variables that get added to the init container (useful for e.g. http_proxy)
  # InitContainerEnv:
  #   - name: http_proxy
  #     value: "http://192.168.64.1:3128"
  # ContainerEnv:
  #   - name: http_proxy
  #     value: "http://192.168.64.1:3128"
  # Set min/max heap here if needed with:
  # JavaOpts: "-Xms512m -Xmx512m"
  # JenkinsOpts: ""
  # If you set this prefix and use ingress controller then you might want to set the ingress path below
  # JenkinsUriPrefix: "/jenkins"
  # Enable pod security context (must be `true` if RunAsUser or FsGroup are set)
  UsePodSecurityContext: true
  # Set RunAsUser to 1000 to let Jenkins run as non-root user 'jenkins' which exists in 'jenkins/jenkins' docker image.
  # When setting RunAsUser to a different value than 0 also set FsGroup to the same value:
  # RunAsUser: <defaults to 0>
  # FsGroup: <will be omitted in deployment if RunAsUser is 0>
  ServicePort: 8080
  # For minikube, set this to NodePort, elsewhere use LoadBalancer
  # Use ClusterIP if your setup includes ingress controller
  ServiceType: ClusterIP
  # Master Service annotations
  ServiceAnnotations: {}
  # Master Service Labels
  ServiceLabels: {}
  #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: https
  # Used to create Ingress record (should used with ServiceType: ClusterIP)
  HostName: jenkins.kubecon2018.jonathanhess.com
  # NodePort: <to set explicitly, choose port between 30000-32767
  # Enable Kubernetes Liveness and Readiness Probes
  # ~ 2 minutes to allow Jenkins to restart when upgrading plugins. Set ReadinessTimeout to be shorter than LivenessTimeout.
  HealthProbes: true
  HealthProbesLivenessTimeout: 90
  HealthProbesReadinessTimeout: 60
  HealthProbeLivenessFailureThreshold: 12
  SlaveListenerPort: 50000
  DisabledAgentProtocols:
    - JNLP-connect
    - JNLP2-connect
  CSRF:
    DefaultCrumbIssuer:
      Enabled: true
      ProxyCompatability: true
  CLI: false
  # Kubernetes service type for the JNLP slave service
  # SETTING THIS TO "LoadBalancer" IS A HUGE SECURITY RISK: https://github.com/kubernetes/charts/issues/1341
  SlaveListenerServiceType: ClusterIP
  SlaveListenerServiceAnnotations: {}
  LoadBalancerSourceRanges:
  - 0.0.0.0/0
  # Optionally assign a known public LB IP
  # LoadBalancerIP: 1.2.3.4
  # Optionally configure a JMX port
  # requires additional JavaOpts, ie
  # JavaOpts: >
  #   -Dcom.sun.management.jmxremote.port=4000
  #   -Dcom.sun.management.jmxremote.authenticate=false
  #   -Dcom.sun.management.jmxremote.ssl=false
  # JMXPort: 4000
  # Optionally configure other ports to expose in the Master container
  ExtraPorts:
  # - name: BuildInfoProxy
  #   port: 9000
  # List of plugins to be install during Jenkins master start
  InstallPlugins:
    - kubernetes:1.12.4
    - workflow-job:2.24
    - workflow-aggregator:2.5
    - credentials-binding:1.16
    - git:3.9.1
    - groovy:2.0 # added to suppor the backup and restore jobs
  # Used to approve a list of groovy functions in pipelines used the script-security plugin. Can be viewed under /scriptApproval
  # ScriptApproval:
  #   - "method groovy.json.JsonSlurperClassic parseText java.lang.String"
  #   - "new groovy.json.JsonSlurperClassic"
  # List of groovy init scripts to be executed during Jenkins master start
  InitScripts:
  #  - |
  #    print 'adding global pipeline libraries, register properties, bootstrap jobs...'
  # Kubernetes secret that contains a 'credentials.xml' for Jenkins
  # CredentialsXmlSecret: jenkins-credentials
  # Kubernetes secret that contains files to be put in the Jenkins 'secrets' directory,
  # useful to manage encryption keys used for credentials.xml for instance (such as
  # master.key and hudson.util.Secret)
  # SecretsFilesSecret: jenkins-secrets
  # Jenkins XML job configs to provision
  Jobs: >-
    restore-jenkins-config: |-
      <?xml version='1.1' encoding='UTF-8'?>
      <project>
        <actions/>
        <description></description>
        <keepDependencies>false</keepDependencies>
        <properties>
          <hudson.model.ParametersDefinitionProperty>
            <parameterDefinitions>
              <hudson.model.FileParameterDefinition>
                <name>jenkins-home.tar.gz</name>
                <description>Upload the jenkins home file from the backup job.</description>
              </hudson.model.FileParameterDefinition>
            </parameterDefinitions>
          </hudson.model.ParametersDefinitionProperty>
        </properties>
        <scm class="hudson.scm.NullSCM"/>
        <assignedNode>master</assignedNode>
        <canRoam>false</canRoam>
        <disabled>false</disabled>
        <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
        <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
        <triggers/>
        <concurrentBuild>false</concurrentBuild>
        <builders>
          <hudson.tasks.Shell>
            <command>set -x

      ls -al

      mkdir -p jenkins-home

      (
      echo
          echo
          echo &quot;**** Contents of Jenkins Home Before&quot;
        ls -al $JENKINS_HOME/
          ls -al $JENKINS_HOME/jobs/

        cd $JENKINS_HOME
        tar -vzxf $WORKSPACE/jenkins-home.tar.gz 

        echo
          echo
        echo &quot;**** Contents of Jenkins Home After&quot;


          ls -al $JENKINS_HOME/
          ls -al $JENKINS_HOME/jobs/

      )
      /usr/local/bin/install-plugins.sh

      </command>
          </hudson.tasks.Shell>
          <hudson.plugins.groovy.SystemGroovy plugin="groovy@2.0">
            <source class="hudson.plugins.groovy.StringSystemScriptSource">
              <script plugin="script-security@1.48">
                <script>import hudson.model.*
      println &quot;Starting hudson reload...&quot;
      Hudson.instance.doReload()
      println &quot;Finished hudson reload.&quot;
      </script>
                <sandbox>false</sandbox>
              </script>
            </source>
          </hudson.plugins.groovy.SystemGroovy>
        </builders>
        <publishers/>
        <buildWrappers/>
      </project>
    backup-jenkins-config: |-
      <?xml version='1.1' encoding='UTF-8'?>
      <project>
        <actions/>
        <description></description>
        <keepDependencies>false</keepDependencies>
        <properties/>
        <scm class="hudson.scm.NullSCM"/>
        <assignedNode>master</assignedNode>
        <canRoam>false</canRoam>
        <disabled>false</disabled>
        <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
        <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
        <triggers/>
        <concurrentBuild>false</concurrentBuild>
        <builders>
          <hudson.tasks.Shell>
            <command>set -x

      echo &quot;Backing Up!&quot;
      #ls -al $JENKINS_HOME/
      #ls -al $JENKINS_HOME/plugins
      #find $JENKINS_HOME/plugins/artifactory -ls

      rm -f jenkins-home.tar || echo &quot;don&apos;t care&quot;

      # From within the jenkins home directory

      ( # subshell, cd to Jenkins Home
      cd $JENKINS_HOME

      # Get all the configuration stuff from jenkins_home
      # excluding transient state like caches and logs
      # excluding non-configuration state like job results and workspaces
      tar -cvf $WORKSPACE/jenkins-home.tar \
        --exclude=caches \
        --exclude=config-history \
        --exclude=logs \
        --exclude=jobs \
        --exclude=config-history \
        --exclude=fingerprints \
        --exclude=plugins \
        --exclude=war \
        --exclude=workspace \
        *

      # Grab job config.xml and build numbers
      tar --append -vf $WORKSPACE/jenkins-home.tar \
        --exclude &quot;jobs/backup-jenkins-config/builds&quot; \
        --exclude &quot;jobs/*/builds/*/archive&quot; \
        --exclude &quot;jobs/*/fileParameters/*/archive&quot; \
        jobs/*

      )


      ##
      # Make a helm chart of all the right jenkins extension versions
      #
      echo &gt; jenkins-extensions.txt
      for pluginManifest in $JENKINS_HOME/plugins/*/META-INF/MANIFEST.MF ; do
          extensionName=$(perl -n -e &apos;if(/Extension-Name: (.*)$/) { $a = $1 ; chop($a) ; print $a}&apos; $pluginManifest )
          extensionVersion=$(perl -n -e &apos;if(/Plugin-Version: (.*)$/) { $a = $1 ; chop($a) ; print $a}&apos; $pluginManifest )
          printf &quot;%s:%s\n&quot; &quot;${extensionName}&quot; &quot;${extensionVersion}&quot; &gt;&gt; jenkins-extensions.txt
      done

      tar --append -vf $WORKSPACE/jenkins-home.tar \
        jenkins-extensions.txt

      rm jenkins-home.tar.gz || echo &quot;don&apos;t care&quot;
      gzip jenkins-home.tar

      echo &quot;DONE&quot;</command>
          </hudson.tasks.Shell>
        </builders>
        <publishers>
          <hudson.tasks.ArtifactArchiver>
            <artifacts>jenkins-home.tar.gz</artifacts>
            <allowEmptyArchive>false</allowEmptyArchive>
            <onlyIfSuccessful>false</onlyIfSuccessful>
            <fingerprint>false</fingerprint>
            <defaultExcludes>true</defaultExcludes>
            <caseSensitive>true</caseSensitive>
          </hudson.tasks.ArtifactArchiver>
        </publishers>
        <buildWrappers/>
      </project>
  CustomConfigMap: false
  # By default, the configMap is only used to set the initial config the first time
  # that the chart is installed.  Setting `OverwriteConfig` to `true` will overwrite
  # the jenkins config with the contents of the configMap every time the pod starts.
  OverwriteConfig: false
  # Node labels and tolerations for pod assignment
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  NodeSelector: {}
  Tolerations: {}
  PodAnnotations: {}

  Ingress:
    ApiVersion: extensions/v1beta1
    Annotations: 
      certmanager.k8s.io/cluster-issuer: letsencrypt-staging # Reference our cert manager
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

    # Set this path to JenkinsUriPrefix above or use annotations to rewrite path
    # Path: "/jenkins"

    TLS:
    - secretName: jenkins-tls
      hosts:
        - jenkins.kubecon2018.jonathanhess.com #TODO replace with your hostname
  AdditionalConfig: {}

Agent:
  Enabled: true
  Image: jenkins/jnlp-slave
  ImageTag: 3.10-1
  CustomJenkinsLabels: []
# ImagePullSecret: jenkins
  Component: "jenkins-slave"
  Privileged: false
  resources:
    requests:
      cpu: "200m"
      memory: "256Mi"
    limits:
      cpu: "200m"
      memory: "256Mi"
  # You may want to change this to true while testing a new image
  AlwaysPullImage: false
  # Controls how slave pods are retained after the Jenkins build completes
  # Possible values: Always, Never, OnFailure
  PodRetention: Never
  # You can define the volumes that you want to mount for this container
  # Allowed types are: ConfigMap, EmptyDir, HostPath, Nfs, Pod, Secret
  # Configure the attributes as they appear in the corresponding Java class for that type
  # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes
  volumes: 
  - type: Secret
    mountPath: "/var/jenkins_home/.ssh"
    secretName: jenkins-user-ssh-secrets
  - type: PersistentVolumeClaim
    mountPath: "/mount/jenkins-shared"
    claimName: jenkins-shared-pvc


  NodeSelector: {}
  # Key Value selectors. Ex:
  # jenkins-agent: v1

Persistence:
  Enabled: true
  # Enabled: true # note we are not using PV because Rook is bad
  ExistingClaim: jenkins-home-pvc

  ## A manually managed Persistent Volume and Claim
  ## Requires Persistence.Enabled: true
  ## If defined, PVC must be created manually before volume will be bound

  ## jenkins data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # StorageClass: "rook-block-double"
  # AccessMode: ReadWriteOnce
  # Size: 50Gi

  # Useful things to put on all jenkins slaves:
  #
  # A standard SSH key for pulling from Git
  # A shared file for passing really big files between build stages
  #
  volumes:
    - name: jenkins-user-ssh-secrets
      secret:
        secretName: jenkins-user-ssh-secrets
        defaultMode: 0x180 # oct 600
    - name: jenkins-shared
      persistentVolumeClaim:
        claimName: jenkins-shared-pvc
  mounts:
    - name: jenkins-user-ssh-secrets
      readOnly: true
      mountPath: "/var/jenkins_home/.ssh"
    - name: jenkins-shared
      readOnly: false
      mountPath: "/mount/jenkins-shared"

NetworkPolicy:
  # Enable creation of NetworkPolicy resources.
  Enabled: false
  # For Kubernetes v1.4, v1.5 and v1.6, use 'extensions/v1beta1'
  # For Kubernetes v1.7, use 'networking.k8s.io/v1'
  ApiVersion: extensions/v1beta1

## Install Default RBAC roles and bindings
rbac:
  install: true
  # Use a different service account name
  # don't just use default:default. For a tiny bit of added safety.
  serviceAccountName: jenkins 
  # Role reference
  roleRef: cluster-admin
  # Role kind (RoleBinding or ClusterRoleBinding)
  roleBindingKind: ClusterRoleBinding