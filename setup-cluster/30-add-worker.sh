#!/bin/bash
set -eio pipefail

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
cd $DIR

source ./files/common
source $DIR/out/common # Use the AWS testbed, override cluster spec in files/common with out/common 

#
# SSH to the master and grep the join command generated by `kubeadm init` out of the log
#
JOIN_COMMAND_RAW=`ssh $SSH_OPTS  admin@$MASTER_NODE_HOSTNAME bash <<< 'grep "kubeadm join" "kubeadm-init.log"'`
JOIN_COMMAND=$(echo "$JOIN_COMMAND_RAW" | sed 's/kubeadm join/kubeadm join --ignore-preflight-errors cri/' )

echo "Join: sudo $JOIN_COMMAND"

#
# SSH to the worker node, run `kubadm join` with the right key, and then 
# do some editing of configuration files to correct a bug with kubedns
#
function joinNode() {
    local node_hostname=$1
    ssh $SSH_OPTS  admin@$node_hostname sudo bash <<EOF
    ${JOIN_COMMAND}
sudo systemctl daemon-reload
sudo systemctl restart kubelet docker
EOF

}

#
# Iterate through the worker nodes and join the cluster one at a time
# Note if you try to join more than 1 at a time, you can get race conditions and
# nodes won't actually join.
#
echo "Prepareing nodes with basic dependencies for the kubernetes cluster"
if [ $# -gt 0 ]; then
    for node_hostname in $@ ; do 
        joinNode $node_hostname;
    done
else
    for node_hostname in ${WORKER_NODES_HOSTNAMES[*]} ; do 
        joinNode $node_hostname;
    done
fi
